# Trust Splitwise Smart Contracts

This repository carries the backend logic for the Trust Splitwise project: Solidity smart contracts, Hardhat automation, and the supporting documentation required to deploy, measure, and analyze the decentralized expense-sharing system. All front-end code lives elsewhere.

---

## Overview

The contract suite enables participants to:

- create expense-sharing groups (up to 50 members per group),
- register expenses under equal or exact split modes,
- execute an off-chain debt-simplification pass and verify the resulting plan on-chain, and
- settle debts with the purpose-built ERC-20 token `TrustToken`.

Everything resides inside a Hardhat workspace, so local deployment, testing, and gas inspection are frictionless.

---

## Scope and Stack

| Component | Details |
|-----------|---------|
| Language | Solidity 0.8.28 |
| Framework | Hardhat, ethers.js, OpenZeppelin libraries |
| Core Contracts | `Splitwise.sol`, `TrustToken.sol` |
| Automation | Node scripts in `scripts/` for deployment, expense logging, simplification, inspection, and cleanup |
| Documentation | LaTeX report (`report/main.tex`) and supplementary plans within `docs/` |

---

## Repository Layout

| Path | Purpose |
|------|---------|
| `contracts/` | Sources for `Splitwise.sol` and `TrustToken.sol` |
| `scripts/` | Task-focused Hardhat runners (deploy, create group, add expense, simplify debts, check balances/debts, cleanup) |
| `test/` | Scenario-based Hardhat tests that stress creation, settlement, and simplification edge cases |
| `artifacts/`, `cache/` | Build results generated by Hardhat (regenerable) |
| `report/` | Course report with architectural decisions, benchmarks, and references |
| `docs/` | Design notes, planning logs, and architectural discussions |

---

## Core Capabilities

### Splitwise.sol — Group expense manager

Handles the group lifecycle, expense logging, and the directed debt graph.

**Feature summary**

- Group creation, invitations, and membership tracking with a locking mechanism for critical operations.
- Equal and exact split support, with salted expense hashes for replay protection.
- Commit-and-apply workflow for debt simplification, keyed by `keccak256` hashes.
- `nonReentrant`-guarded settlement that transfers `TrustToken` balances.
- Emission of rich events to drive off-chain automation.

**Primary data structures**

| Structure | Description |
|-----------|-------------|
| `Group` | Member roster, hash of the current debt graph, per-group nonce, and a lock bit |
| `ExpenseData` | Full payload for each expense (participants, amounts, metadata) |
| `SimplifiedEdge` | Directed obligation generated by the off-chain simplifier |

### TrustToken.sol — Settlement token

ERC-20 compliant token contract with a fixed mint rate. Integrates `SafeERC20` helpers and `ReentrancyGuard` to protect settlement flows triggered from `Splitwise.sol`.

---

## Architecture and Workflow

1. **Create group** – `createGroup()` stores the creator and opens invitations.
2. **Invite members** – `inviteMember()` adds new addresses while enforcing the 50-member cap.
3. **Register expense** – `registerExpense()` persists hashed payloads and updates the adjacency matrix of debts.
4. **Simplify debts (off-chain)** – an $O(n^2)$ greedy pass visits the full graph, cancels opposing balances, and produces `SimplifiedEdge[]`.
5. **Commit simplification** – `commitSimplification(bytes32 edgesHash)` anchors the next plan.
6. **Apply simplification** – `applySimplification(SimplifiedEdge[])` validates the payload against the committed hash, clears the graph, and writes the simplified edges (still $O(n^2)$ because of the reset loops).
7. **Settle debts** – `settleDebt()` performs token transfers with `nonReentrant` safety.

---

## Debt-Simplification Complexity

- Reading the adjacency matrix touches up to $n(n-1)$ entries, yielding $O(n^2)$ IO.
- The greedy cancellation compares balances pairwise, producing another $O(n^2)$ factor.
- `applySimplification` clears the matrix before inserting the simplified edges, maintaining overall quadratic cost.

---

## Reality Check

1. **Scale limits** – quadratic reads/writes make groups above ~20 members expensive unless the workflow is migrated to a cheaper execution environment.
2. **Trusted simplifier** – the off-chain simplification payload still requires trust; a decentralized oracle or proof mechanism would reduce that reliance.
3. **Commit flooding** – `commitSimplification` is permissionless; rate limits or staking could limit spam.
4. **Scripted UX** – all interactions are CLI-driven; a frontend lives in a separate repository.
5. **Gas profile** – `applySimplification` rewrites the entire matrix for correctness, trading higher gas fees for simpler verification.

---

## Installation

```bash
git clone <repository-url>
cd splitWise
npm install
```

## Testing

```bash
npx hardhat test
```

The suite covers deterministic scenarios (group creation, expense flows) and larger randomized cases under `test/splitwise_large*.test.js`.

---

## Scripted Usage

Run these commands against a local Hardhat node (`npx hardhat node`) or a configured network via `--network <name>`:

```bash
npx hardhat run scripts/deploy.js --network localhost
npx hardhat run scripts/create_group.js --network localhost
npx hardhat run scripts/add_expense.js --network localhost
npx hardhat run scripts/simplify_debts.js --network localhost
npx hardhat run scripts/check_balance.js --network localhost
npx hardhat run scripts/check_debts.js --network localhost
npx hardhat run scripts/cleanup.js --network localhost
```

Each script performs a discrete task so the pipeline remains transparent and reproducible.

---

## Next Steps

- Add percentage and custom split modes.
- Support member removal and optional service fees.
- Introduce staking or rate limits around debt-commit submissions.
- Explore Layer-2 deployment and zk-powered proofs to minimize trust in the simplifier.

---

This repository is intentionally backend-only. Integrate the contracts with a dedicated frontend or additional automation (Foundry, Dune, custom dashboards) for user-facing deployments.

